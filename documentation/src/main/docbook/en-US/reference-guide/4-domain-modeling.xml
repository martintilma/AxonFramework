<?xml version="1.0" encoding="UTF-8"?>
<!--
    ~ Copyright (c) 2010. Axon Framework
    ~
    ~ Licensed under the Apache License, Version 2.0 (the "License");
    ~ you may not use this file except in compliance with the License.
    ~ You may obtain a copy of the License at
    ~
    ~     http://www.apache.org/licenses/LICENSE-2.0
    ~
    ~ Unless required by applicable law or agreed to in writing, software
    ~ distributed under the License is distributed on an "AS IS" BASIS,
    ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    ~ See the License for the specific language governing permissions and
    ~ limitations under the License.
-->
<chapter xml:id="domain-modeling" version="5.0" xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude">
    <title>Domain Modeling</title>
    <para>In a CQRS-based application, a Domain Model (as defined by Eric Evans and Martin Fowler)
        can be a very powerful mechanism to harness the complexity involved in the validation and
        execution of state changes. Although a typical Domain Model has a great number of building
        blocks, two of them play a major role when applied to CQRS: the Event and the
        Aggregate.</para>
    <para>The following sections will explain the role of these building blocks and how to implement
        them using the Axon Framework.</para>
    <sect1 xml:id="events">
        <title>Events</title>
        <para>The Axon Framework makes a distinction between three types of events, each with a
            clear use and type of origin. Regardless of their type, all events must implement the
                <code>Event</code> interface or one of the more specific sub-types, Domain Events,
            Application Events and System Events, each described in the sections below.</para>
        <para>All events may carry data and meta-data. Typically, the data is added to each event as
            fields in the event implementation. Meta-data, on the other hand is stored separately.
            The Auditing interceptor uses this mechanism to attach meta-data to events for auditing
            purposes. All Axon's implementations of Events allow the subclasses to attach arbitrary
            information as meta-data.</para>
        <note>
            <para>In general, you should not base business decisions on information in the meta-data
                of events. If that is the case, you might have information attached that should
                really be part of the event's regular data instead. Meta-data is typically used for
                auditing and tracing.</para>
        </note>
        <sect2 xml:id="domain-events">
            <title>Domain Events</title>
            <para>The most important type of event in any CQRS application is the domain event. It
                represents an event that occurs inside your domain logic, such as a state change or
                special notification of a certain state. The latter not being per definition a state
                change. </para>
            <para>In the Axon Framework, all domain events should extend the abstract
                    <code>DomainEvent</code> class. This abstract class keeps track of the aggregate
                they are generated by, and the sequence number of the event inside the aggregate.
                This information is important for the Event Sourcing mechanism, as well as for event
                handlers (see <xref linkend="event-listeners"/>) that need to know the origin of an
                event. </para>
            <para>Although not enforced, it is good practice to make domain events immutable,
                preferably by making all fields final and by initializing the event within the
                constructor. </para>
            <note>
                <para>Although Domain Events technically indicate a state change, you should try to
                    capture the intention of the state in the event, too. A good practice is to use
                    an abstract implementation of a domain event to capture the fact that certain
                    state has changed, and use a concrete sub-implementation of that abstract class
                    that indicates the intention of the change. For example, you could have an
                    abstract <code>AddressChangedEvent</code>, and two implementations
                        <code>ContactMovedEvent</code> and <code>AddressCorrectedEvent</code> that
                    capture the intent of the state change. Some listeners don't care about the
                    intent (e.g. database updating event listeners). These will listen to the
                    abstract type. Other listeners do care about the intent and these will listen to
                    the concrete subtypes (e.g. to send an address change confirmation email to the
                    customer). </para>
                <figure>
                    <title>Adding intent to events</title>
                    <mediaobject>
                        <imageobject role="fo">
                            <imagedata format="png" fileref="state-change-intent-hires.png"
                                width="10cm"/>
                        </imageobject>
                        <imageobject role="html">
                            <imagedata format="png" fileref="state-change-intent.png"/>
                        </imageobject>
                    </mediaobject>
                </figure>
            </note>
            <para>There is a special type of <code>Event</code>, which has a special meaning: the
                    <code>AggregateDeletedEvent</code>. This is a marker interface that indicates a
                migration to a "deleted" state of the aggregate. Repositories must treat aggregates
                that have applied such an event as deleted. Hence, loading an aggregate that has an
                    <code>AggregateDeletedEvent</code> results in an exception.</para>
            <para>Snapshot events are instances of <code>DomainEvent</code> with a special intent.
                They are typically not dispatched via the event bus, but are used to summarize an
                arbitrary number of events from the past into a single entry. This can drastically
                improve performance when initializing an aggregate's state from a series of events.
                See <xref linkend="using-snapshot-events"/> for more information about snapshot
                events and their use.</para>
        </sect2>
        <sect2>
            <title>Application Events</title>
            <para>Application events are events that cannot be categorized as domain events, but do
                have a significant importance for the application. When using application events,
                check if the event is actually a domain event that you overlooked. Examples of
                application events are the expiry of a user session, or the notification of an email
                being successfully sent. The usefulness of these events depend on the type of
                application you are creating.</para>
            <para>In the Axon Framework, you can extend the abstract <code>ApplicationEvent</code>
                class for application events. This class will generate a unique identifier and a
                time stamp for the current event. Optionally, you can attach an object that acts as
                the source of the event. This source is loosely referenced, which means that if the
                garbage collector cleans up the source, or when the event is serialized and
                de-serialized, the original source class is not available anymore. Instead, you will
                have access to the type of source and the value of it's <code>toString()</code>
                method.</para>
        </sect2>
        <sect2>
            <title>System Events</title>
            <para>The third type of event identified by Axon Framework is the System Event. These
                events typically provide notifications of the status of the system. These events
                could, for example, indicate that a subsystem is non-responsive or has raised an
                exception.
            </para>
            <para>All system events extend the abstract <code>SystemEvent</code> class. Upon
                construction of this event, you may pass an exception, defining the cause of the
                event, and a source object which is considered the source of the event. As with
                application events, the source is loosely referenced from the event. </para>
        </sect2>
    </sect1>
    <sect1>
        <title>Aggregate</title>
        <para>An Aggregate is an entity or group of entities that is always kept in a consistent
            state. The aggregate root is the object on top of the aggregate tree that is responsible
            for maintaining this consistent state.
        </para>
        <note>
            <para>The term "Aggregate" refers to the aggregate as defined by Evans in Domain Driven
                Design: </para>
            <para>
                <quote>A cluster of associated objects that are treated as a unit for the purpose of
                    data changes. External references are restricted to one member of the Aggregate,
                    designated as the root. A set of consistency rules applies within the
                    Aggregate's boundaries. </quote>
            </para>
            <para>A more extensive definition can be found on: <link
                    xmlns:ns1="http://www.w3.org/1999/xlink"
                    ns1:href="http://domaindrivendesign.org/freelinking/Aggregate"
                    >http://domaindrivendesign.org/freelinking/Aggregate</link>. </para>
        </note>
        <para>For example, a "Contact" aggregate will contain two entities: contact and address. To
            keep the entire aggregate in a consistent state, adding an address to a contact should
            be done via the contact entity. In this case, the Contact entity is the appointed
            aggregate root.</para>
        <para>In Axon, aggregates are identified by an <code>AggregateIdentifier</code>. There are
            two basic implementations of these identifiers: <code>UUIDAggregateIdentifier</code>,
            which used Java's <code>UUID</code> to generate random identifiers, and the
                <code>StringAggregateIdentifier</code>, which allows you to choose a
                <code>String</code> which should be used as identifier. You can choose any
            identifier type you like, and even create your own, as long as they have a valid String
            representation.</para>
        <note>
            <para>It is considered a good practice to use randomly generated identifiers, as opposed
                to sequenced ones. Using a sequence drastically reduces scalability of your
                application, since machines need to keep each other up-to-date of the last used
                sequence numbers. The chance of collisions with a UUID is very slim (a chance of
                    10<superscript>−15</superscript>, if you generate 8.2 ×
                    10<superscript>11</superscript> UUIDs).</para>
            <para>Furthermore, be careful when using functional identifiers for aggregates. They
                have a tendency to change, making it very hard to adapt your application
                accordingly.</para>
        </note>
        <sect2>
            <title>Basic aggregate implementations</title>
            <simplesect>
                <title>
                    <code xmlns="http://docbook.org/ns/docbook">AggregateRoot</code>
                </title>
                <para>In Axon, all aggregate roots must implement the <code>AggregateRoot</code>
                    interface. This interface describes the basic operations needed by the
                    Repository to store and publish the generated domain events. However, Axon
                    Framework provides a number of abstract implementations that help you writing
                    your own aggregates. </para>
                <note>
                    <para>Note that only the aggregate root needs to implement the
                            <code>AggregateRoot</code> interface or implement one of the abstract
                        classes mentioned below. The other entities that are part of the aggregate
                        do not have to implement any interfaces. </para>
                </note>
            </simplesect>
            <simplesect>
                <title>
                    <code>AbstractAggregateRoot</code>
                </title>
                <para>The
                    <code>AbstractAggregateRoot</code>
                    is a basic implementation that provides
                    a
                    <code>registerEvent(DomainEvent)</code>
                    method that you can call in your
                    business logic method to have an event added to the list of uncommitted events.
                    The
                    <code>AbstractAggregateRoot</code>
                    will keep track of all uncommitted
                    registered events and make sure they are forwarded to the event bus when the
                    aggregate is saved to a repository.
                </para>
            </simplesect>
            <simplesect>
                <title><code>AbstractJpaAggregateRoot</code></title>
                <para>The <code>AbstractJpaAggregateRoot</code> is a JPA-compatible implementation
                    of the <code>AggregateRoot</code> interface. It has the annotation necessary to
                    persist the aggregate's state and reconstruct it from database tables. It uses
                    the <code>@Version</code> annotation on one of it's field to perform optimistic
                    locking on the database level. Similar to the
                    <code>AbstractAggregateRoot</code>, the <code>AbstractJpaAggregateRoot</code>
                    keeps track of uncommitted events, which have been registered using
                        <code>registerEvent(DomainEvent)</code>.</para>
            </simplesect>
        </sect2>
        <sect2>
            <title>Event sourced aggregates</title>
            <para>Axon framework provides a few repository implementations that can use event
                sourcing as storage method for aggregates. These repositories require that
                aggregates implement the <code>EventSourcedAggregateRoot</code> interface. As with
                most interfaces in Axon, we also provide one or more abstract implementations to
                help you on your way. </para>
            <simplesect>
                <title>
                    <code>EventSourcedAggregateRoot</code>
                </title>
                <para>The interface <code>EventSourcedAggregateRoot</code> defines an extra method,
                        <code>initializeState()</code>, on top of the <code>AggregateRoot</code>
                    interface. This method initializes an aggregate's state based on an event
                    stream. </para>
            </simplesect>
            <simplesect>
                <title>
                    <code>AbstractEventSourcedAggregateRoot</code>
                </title>
                <para>The <code>AbstractEventSourcedAggregateRoot</code> implements all methods on
                    the <code>EventSourcedAggregateRoot</code> interface. It defines an abstract
                        <code>handle()</code> method, which you need to implement with the actual
                    logic to apply state changes based on domain events. When you extend the
                        <code>AbstractEventSourcedAggregateRoot</code>, you can register new events
                    using <code>apply()</code>. This method will register the event to be committed
                    when the aggregate is saved, and will call the <code>handle()</code> method with
                    the event as parameter. You need to implement this <code>handle()</code> method
                    to apply the state changes represented by that event. Below is a sample
                    implementation of an aggregate.</para>
                <programlisting language="java">public class MyAggregateRoot extends AbstractEventSourcedAggregateRoot {

    private String someProperty;

    public MyAggregateRoot() {
        apply(new MyAggregateCreatedEvent());
    }

    public MyAggregateRoot(UUID identifier) {
        super(identifier);
    }

    public void handle(DomainEvent event) {
        if (event instanceof MyAggregateCreatedEvent) {
            // do something with someProperty
        }
        // and more if-else-if logic here
    }
}                </programlisting>
            </simplesect>
            <simplesect xml:id="annotated-aggregate-root">
                <title>
                    <code>AbstractAnnotatedAggregateRoot</code>
                </title>
                <para>As you see in the example above, the implementation of the
                    <code>handle()</code>
                    method can become quite verbose and hard to read. The
                    <code>AbstractAnnotatedAggregateRoot</code>
                    can help. The
                    <code>AbstractAnnotatedAggregateRoot</code>
                    is a specialization of the
                    <code>AbstractAggregateRoot</code>
                    that provides
                    <code>@EventHandler</code>
                    annotation support to your aggregate. Instead of a single
                    <code>handle()</code>
                    method, you can split the logic in separate methods, with names that you may
                    define yourself. Just annotate the event handler methods with
                    <code>@EventHandler</code>, and the
                    <code>AbstractAnnotatedAggregateRoot</code>
                    will invoke the right method for
                    you.
                </para>
                <note>
                    <para>Note that <code>@EventHandler</code> annotated methods on an
                            <code>AbstractAnnotatedAggregateRoot</code> are only called when events
                        are applied directly to the aggregate locally. This should not be confused
                        with annotating event handler methods on <code>EventListener</code> classes,
                        in which case event handler methods handle events dispatched by the
                            <code>EventBus</code>. See <xref linkend="event-listeners"/>. </para>
                </note>
                <programlisting language="java">public class MyAggregateRoot extends AbstractAnnotatedAggregateRoot {
    private String someProperty;

    public MyAggregateRoot() {
        apply(new MyAggregateCreatedEvent());
    }

    public MyAggregateRoot(UUID identifier) {
        super(identifier);
    }

    @EventHandler
    private void handleMyAggregateCreatedEvent(MyAggregateCreatedEvent event) {
        // do something with someProperty
    }
}</programlisting>
                <para><code>@EventHandler</code> annotated methods are resolved using specific rules. These rules are thorougly explained in <xref linkend="annotated-event-handlers"/>.</para>
                    <note>
                        <title>Using private methods</title>
                        <para>Event handler methods may be private, as long as the security settings of the JVM
                            allow the Axon Framework to change the accessibility of the method. This allows you to
                            clearly separate the public API of your aggregate, which exposes the methods that
                            generate events, from the internal logic, which processes the events.</para>
                    </note>
                
            </simplesect>
        </sect2>
        <sect2>
            <title>Complex Aggregate structures</title>
            <para>Complex business logic often requires more than what an aggregate with only an
                aggregate root can provide. In that case, it important that the complexity is spread
                over a number of entities within the aggregate. When using event sourcing, not only
                the aggregate root needs to use event to trigger state transitions, but so does each
                of the entities within that aggregate.</para>
            <para>Axon provides support for event sourcing in complex aggregate structures. All
                entities other than the aggregate root need to extend from
                    <code>AbstractEventSourcedEntity</code>. The
                    <code>EventSourcedAggregateRoot</code> implementations provided by Axon
                Framework are aware of these entities and will call their event handlers when
                needed.</para>
            <para>When an entity (including the aggregate root) applies an Event, it is registered
                with the Aggregate Root. The aggregate root applies the event locally first. Next,
                it will evaluate all its fields for any implementations of
                    <code>AbstractEventSourcedEntity</code> and handle the event on them. Each
                entity does the same thing to its fields.</para>
            <para>To register an Event, the Entity must know about the Aggregate Root. Axon will
                automatically register the Aggregate Root with an Entity before applying any Events
                to it. This means that Entities (unlike usual in the Aggregate Root) should never
                apply an Event in their constructor. Non-Aggregate Root Entities should be created
                in an <code>@EventHandler</code> annotated method in their parent Entity (as
                creation of an entity can be considered a state change of the Aggregate). Axon will
                ensure that the Aggregate Root is properly registered in time.</para>
            <para>Axon will automatically detect most of the child entities in the fields of an
                Entity (albeit aggregate root or not). The following Entities are found:<itemizedlist>
                    <listitem>
                        <para>directly referenced in a field; </para>
                    </listitem>
                    <listitem>
                        <para>inside fields containing an <code>Iterable</code> (which includes all
                            collections, such as <code>Set</code>, <code>List</code>, etc); </para>
                    </listitem>
                    <listitem>
                        <para>inside both they keys and the values of fields containing a
                                <code>java.util.Map</code></para>
                    </listitem>
                </itemizedlist>If you reference an Entity from any other location than the above
                mentioned, you can override the <code>getChildEntities()</code> method. This method
                should return a <code>Collection</code> of entities that should be notified of the
                Event. Note that each entity is invoked once for each time it is located in the
                returned <code>Collection</code>.</para>
        </sect2>
    </sect1>
       
</chapter>
