<?xml version="1.0" encoding="UTF-8"?>
<!--
    ~ Copyright (c) 2010. Axon Framework
    ~
    ~ Licensed under the Apache License, Version 2.0 (the "License");
    ~ you may not use this file except in compliance with the License.
    ~ You may obtain a copy of the License at
    ~
    ~     http://www.apache.org/licenses/LICENSE-2.0
    ~
    ~ Unless required by applicable law or agreed to in writing, software
    ~ distributed under the License is distributed on an "AS IS" BASIS,
    ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    ~ See the License for the specific language governing permissions and
    ~ limitations under the License.
-->
<chapter xml:id="event-processing" version="5.0" xmlns="http://docbook.org/ns/docbook">
    <title>Event Processing</title>
    <para>The Events generated by the application need to be dispatched to the components that
        update the query databases, search engines or any other resources that need them: the Event
        Listeners. This is the responsibility of the Event Bus. Axon Framework provides an Event Bus
        and some base classes to help you implement Event Listeners.</para>
    <sect1 xml:id="event-bus">
        <title>Event Bus</title>
        <para>The <code>EventBus</code> is the mechanism that dispatches events to the subscribed
            event listeners. Axon Framework provides two implementation of the event bus:
                <code>SimpleEventBus</code> and <code>ClusteringEventBus</code>. Both
            implementations manages subscribed <code>EventListeners</code> and forward all incoming
            events to all subscribed listeners. This means that Event Listeners must be explicitly
            registered with the Event Bus in order for them to receive events. The registration
            process is thread safe. Listeners may register and unregister for events at any
            time.</para>
        <sect2>
            <title>Simple Event Bus</title>
            <para>The <code>SimpleEventBus</code> is, as the name suggests, a very basic
                implementation of the <code>EventBus</code> interface. It just dispatches each
                incoming <code>Event</code> to each of the subscribed <code>EventListeners</code>
                sequentiall. If an EventListener throws an <code>Exception</code>, dispatching stops
                and the exception is propagated to the component publising the
                <code>Event</code>.</para>
            <para>The <code>SimpleEventBus</code> is suitable for most cases where dispatching is
                only done locally, in a single JVM. Once you application requires
                    <code>Events</code> to be published across multiple JVMs, you could consider
                using the <code>ClusteringEventBus</code> instead.</para>
        </sect2>
        <sect2>
            <title>Clustering Event Bus</title>
            <para>The <code>ClusteringEventsBus</code> allows application developers to bundle
                    <code>EventListener</code>s into <code>Cluster</code>s based on their properties
                and non-functional requirements. The ClusteringEventBus is also more capable to deal
                with Events being dispatched among different machines.</para>
            <para>The ClusteringEventsBus contains two mechanisms: the <code>ClusterSelector</code>,
                which selects a <code>Cluster</code> instance for each of the registered
                    <code>EventListener</code>s, and the <code>EventBusTerminal</code>, which is
                responsible for dispatching Events to each of the relevant clusters.</para>
            <note>
                <title>Background: Axon Terminal</title>
                <para>In the nervous system, an Axon (one of the components of a Neuron) transports
                    electrical signals. These Neurons are interconnected in very complex
                    arrangements. The Axon Terminal is responsible for transmitting these signals
                    from one Neuron to another.</para>
                <para>More information: <link xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="www.wikipedia.org/wiki/Axon_terminal"
                        >www.wikipedia.org/wiki/Axon_terminal</link>.</para>
            </note>
            <simplesect>
                <title><code>ClusterSelector</code></title>
                <para>The primary responsibility of the <code>ClusterSelector</code> is to, as the
                    name suggests, select a cluster for each Event Listener that subscribes to the
                    Event Bus. By default, all Event Listeners are placed in a single Cluster
                    instance, which dispatches events to its members sequentially and in the calling
                    thread (similar to how the <code>SimpleEventBus</code> works). By providing a
                    custom implementation, you can arrange the Event Listeners into different
                    Cluster instances to suit the requirements of your architecture.</para>
                <para>At this moment, there is a single implementation of the <code>Cluster</code>
                    interface: <code>SimpleCluster</code>. This implementation calls each
                    EventListener sequentially in the calling thread. By adding information in the
                    Meta Data of a cluster, the selector can provide hints to the Terminal about the
                    expected behavior.</para>
            </simplesect>
            <simplesect>
                <title><code>EventBusTerminal</code></title>
                <para>The <code>EventBusTerminal</code> forms the bridge between the events being
                    dispatched and the Clusters inside the Event Bus. The terminal is aware of any
                    remoting technologies used, such as JMS, AMQP, etc. The default implementation
                    dispatches published events to each of the (local) clusters using the publishing
                    thread. This means that with the default terminal, and the default
                        <code>ClusterSelector</code>, the behavior of the
                        <code>ClusteringEventBus</code> is exactly the same as that of the
                        <code>SimpleEventBus</code>.</para>
                <para>In a typical AMQP based configuration, the <code>EventBusTerminal</code> would
                    send published events to an Exchange. For each cluster, a Queue would be
                    connected to that exchange. The <code>EventBusTerminal</code> will create a
                    consumer for each cluster, which reads from its related Queue and forwards each
                    message to that cluster. Event Listeners in a distributed environment where at
                    most one instance should receive an Events should be placed in a separate
                    cluster, which competes with the other instances on a single Queue.</para>
            </simplesect>
        </sect2>
    </sect1>
    <sect1 xml:id="event-listeners">
        <title>Event Listeners</title>
        <para>Event listeners are the component that act on incoming events. These events may be of
            any type of the events mentioned in <xref linkend="events"/>. In the Axon Framework, all
            event listeners must implement the <code>EventListener</code> interface. </para>
        <sect2>
            <title>Basic configuration</title>
            <para>Event listeners need to be registered with an event bus (see <xref
                    linkend="event-bus"/>) to be notified of events. Axon provides a base
                implementation that take care of this, and other things, for you. </para>
        </sect2>
        <sect2 xml:id="annotated-event-handlers">
            <title>Annotated Event Handler</title>
            <simplesect>
                <title>
                    <code>AnnotationEventListenerAdapter</code></title>
                <para>The <code>AnnotationEventListenerAdapter</code> can wrap any object into an
                    event listener. The adapter will invoke the most appropriate event handler
                    method available. These event handler methods must be annotated with the
                        <code>@EventHandler</code> annotation and are resolved according the
                        following rules:</para>
                <para>
                    TODO explain multiple parameters, first defines event type. Rest is metadata blabla, customizable.
                    <orderedlist>
                        <listitem><para>Some explanation</para></listitem>
                    </orderedlist>
                    
                    In all circumstances, exactly one event
                    handler method is invoked per listener instance. Axon will search the most specific method to invoke, in the following
                    order: <orderedlist>
                        <listitem>
                            <para>On the actual instance level of the class hierarchy (as returned by
                                <code>this.getClass()</code>), all annotated methods are evaluated </para>
                        </listitem>
                        <listitem>
                            <para>If one or more methods are found of which the parameter is of the event type or a
                                super type, the method with the most specific type is chosen and invoked </para>
                        </listitem>
                        <listitem>
                            <para>If no methods are found on this level of the class hierarchy, the super type is
                                evaluated the same way</para>
                        </listitem>
                        <listitem>
                            <para>When the top level of the hierarchy is reached, and no suitable event handler is
                                found, the event is ignored.</para>
                        </listitem>
                    </orderedlist>
                </para>
                <para>The constructor of the <code>AnnotationEventListenerAdapter</code> takes two
                    parameters: the annotated bean, and the <code>EventBus</code>, to which the
                    listener should subscribe. You can subscribe and unsubscribe the event listener
                    using the <code>subscribe()</code> and <code>unsubscribe()</code> methods on the
                    adapter. </para>
                <tip>
                    <para>If you use Spring, you can automatically wrap all annotated event
                        listeners with an adapter automatically by adding
                            <code>&lt;axon:annotation-config/></code> to your application context.
                        Axon will automatically find and wrap annotated event listeners inside an
                            <code>AnnotationEventListenerAdapter</code> and register them with an
                        event bus.</para>
                </tip>
            </simplesect>
        </sect2>
        <sect2>
            <title>Asynchronous event processing</title>
            <para>By default, event listeners process events in the thread that dispatches them.
                This means that the thread that executes the command will have to wait untill all
                event handling has finished. For some types of event listeners this is not the
                optimal form of processing. Asynchronous event processing improves the scalability
                of the application, with the penalty of added complexity to deal with "eventual
                consistency". With the Axon Framework, you can easily convert any event handler into
                an asynchronous event handler by wrapping it in an
                <code>AsynchronousEventHandlerWrapper</code>
                or, when using annotations, adding
                the type-level
                <code>AsynchronousEventListener</code>
                annotation.
            </para>
            <para>The
                <code>AsynchronousEventHandlerWrapper</code>
                needs some extra configuration to
                make an event handler asynchronous. The first thing that the wrapper needs is an
                <code>Executor</code>, for example a <code>ThreadPoolExecutor</code>. The second
                is the <code>SequencingPolicy</code>, a definition of which events may be processed
                in parallel, and which sequentially. The last one is optional: the
                <code>TransactionManager</code>, which enables you to run event processing
                within a transaction. The next pragraphs will provide more details about the
                configuration options.
            </para>
            <para>The
                <code>Executor</code>
                is responsible for executing the event processing. The
                actual implementation most likely depends on the environment that the application
                runs in and the SLA of the event handler. An example is the
                <code>ThreadPoolExecutor</code>, which maintains a pool of threads for the event
                handlers to use to process events. The
                <code>AsynchonousEventHandlerWrapper</code>
                will manage the processing of incoming events in the provided executor. If an
                instance of a
                <code>ScheduledThreadPoolExecutor</code>
                is provided, the
                <code>AsynchronousEventHandlerWrapper</code>
                will automatically leverage its
                ability to schedule processing in the cases of delayed retries. See
                <xref linkend="transactionmanager"/>
                for more information about transactions.
            </para>
            <para>The
                <code>SequencingPolicy</code>
                defines whether events must be handled
                sequentially, in parallel or a combination of both. Policies return a sequence
                identifier of a given event. If two events have the same sequence identifier, this
                means that they must be handled sequentially be the event handler. A
                <code>null</code>
                sequence identifier means the event may be processed in
                parallel with any other event.
            </para>
            <para>Axon provides a number of common policies you can use: <itemizedlist>
                    <listitem>
                        <para>The <code>FullConcurrencyPolicy</code> will tell Axon that this event
                            handler may handle all events concurrently. This means that there is no
                            relationship between the events that require them to be processed in a
                            particular order. </para>
                    </listitem>
                    <listitem>
                        <para>The <code>SequentialPolicy</code> tells Axon that all events must be
                            processed sequentially. Handling of an event will start when the
                            handling of a previous event is finished. For annotated event handlers,
                            this is the default policy. </para>
                    </listitem>
                    <listitem>
                        <para>
                            <code>SequentialPerAggregatePolicy</code> will force domain events that
                            were raised from the same aggregate to be handled sequentially. However,
                            events from different aggregates may be handled concurrently. This is
                            typically a suitable policy to use for event listeners that update
                            details from aggregates in database tables. </para>
                    </listitem>
                </itemizedlist>Besides these provided policies, you can define your own. All
                policies must implement the <code>EventSequencingPolicy</code> interface. This
                interface defines a single method, <code>getSequenceIdentifierFor</code>, that
                returns the identifier sequence identifier for a given event. Events for which an
                equals sequence identifer is returned must be processed sequentially. Events that
                produce a different sequence identifier may be processed concurrently. For
                performance reasons, policy implementations should return <code>null</code> if the
                event may be processed in parallel to any other event. This is faster, because Axon
                does not have to check for any restrictions on event processing. </para>
            <para>A
                <code>TransactionManager</code>
                can be assigned to a
                <code>AsynchronousEventHandlerWrapper</code>
                to add transactional processing of
                events. To optimize processing, events can be processed in small batches inside a
                transaction. The transaction manager has the ability to influence the size of these
                batches and can decide to either commit, skip or retry event processing based on the
                result of a batch. See
                <xref linkend="transactionmanager"/>
                for more
                information.
            </para>
            <simplesect>
                <title>Annotation support for concurrent processing</title>
                <para>If you use the <code>AnnotationEventListenerAdapter</code>, or
                        <code>&lt;axon:annotation-config/></code>, an <code>Executor</code> must be
                    configured to allow asynchronous processing of events.</para>
                <para>You can configure the event sequencing policy on the
                        <code>@AsynchronousEventListener</code> annotation. You then set the
                        <code>sequencePolicyClass</code> to the type of policy you like to use. Note
                    that you can only choose policy classes that provide a public no-arg
                    constructor.
                    <programlisting language="java">@AsynchronousEventListener(sequencingPolicyClass = MyCustomPolicy.class)
public class MyEventListener() {

    @EventHandler
    public void onSomeImportantEvent(MyEvent event) {
        // eventProcessing logic
    }
}

public class MyCustomPolicy implements EventSequencingPolicy {
    public Object getSequenceIdentifierFor(Event event) {
        if (event instanceof MyEvent) {
            // let's assume that we do processing based on the someProperty field.
            return ((MyEvent) event).someProperty();
        }
        return null;
    }
}                    </programlisting>With
                    annotation support, the event handler bean must also act as a transaction
                    manager in order to support transactions. There is annotation support for
                    transaction management, too (see <xref linkend="transactionmanager"/>). </para>
            </simplesect>
        </sect2>
        <sect2 xml:id="transactionmanager">
            <title>Managing transactions in asynchronous event handling</title>
            <para>In some cases, your event handlers have to store data in systems that use
                transactions. Starting and committing a transaction for each single event has a big
                performance impact. In Axon, events are processed in batches. The batch size depends
                of the number of events that need to be processed and the settings provided by the
                event handler. By default, the batch size is set to the number of events available
                in the processing queue at the time a batch starts.</para>
            <note>
                <para>Typically, when using synchronous event handling, the transaction boundary is
                    managed at the Command Bus level. Asynchronous event handlers, on the other
                    hand, run in another thread and are often unable to act within the same
                    transaction. The transaction managers used by event handlers should not be
                    confused with the transaction interceptors, which are used with the Command Bus.
                    See <xref linkend="transactional-interceptor"/> for more information about transactions in
                    the command bus.</para>
            </note>
            <para>In most cases, event handling is done using a thread pool executor, or scheduler.
                The scheduler will schedule batches of event processing as soon as event become
                available. When a batch is completed, the scheduler will reschedule processing of
                the next batch, as long as more events are available. The smaller a batch, the more
                "fair" the distribution of event handler processing is, but also the more scheduling
                overhead you create.</para>
            <para>When an event listener is wrapped with the
                <code>AsynchronousEventHandlerWrapper</code>, you can configure a
                <code>TransactionManager</code>
                to handle transactions for the event listener.
                The transaction manager can, based on the information in the
                <code>TransactionStatus</code>
                object, decide to start, commit or rollback a
                transaction to an external system.
            </para>
            <para>The
                <code>beforeTransaction(TransactionStatus)</code>
                method is invoked just
                before Axon will start handling an event batch. You can use the TransactionStatus
                object to configure the batch before it is started. For example, you can change the
                maximum number of events that may run in the batch.
            </para>
            <para>The
                <code>afterTransaction(TransactionStatus)</code>
                method is invoked after the
                batch has been processed, but before the scheduler has scheduled the next batch.
                Based on the value of <code>isSuccessful()</code>, you can decide to commit or
                rollback the underlying transaction.
            </para>
            <simplesect>
                <title>Configuring transactional batches</title>
                <para>There are a number of settings you can use on the
                    <code>TransactionStatus</code>
                    object.
                </para>
                <para>You can configure a yielding policy, which gives the scheduler an indication
                    of that to do when a batch has finished, but more events are available for
                    processing. Use
                    <code>DO_NOT_YIELD</code>
                    if you want the scheduler to continue
                    processing immediately as long as new events are available for processing. The
                    <code>YIELD_AFTER_TRANSACTION</code>
                    policy will tell the scheduler to
                    reschedule the next batch for processing when a thread is available. The first
                    will make sure events are processed earlier, while the latter provides a fairer
                    execution of events, as yielding provides waiting thread a chance to start
                    processing. The choice of yielding policy should be driven by the SLA of the
                    event listener.
                </para>
                <para>You can set the maximum number of events to handle within a transaction using
                    <code>setMaxTransactionSize(int)</code>. The default of this value is the
                    number of events ready for processing at the moment the transaction started.
                </para>
            </simplesect>
            <simplesect>
                <title>Error handling</title>
                <para>When an event handler throws an exception, for example because a data source
                    is not available, the transaction is marked as failed. In that case,
                    <code>isSuccessful()</code>
                    on the
                    <code>TransactionStatus</code>
                    object
                    will return
                    <code>false</code>
                    and
                    <code>getException()</code>
                    will return the
                    exception that the scheduler caught. It is the responsibility of the event
                    listener to rollback or commit any active underlying transactions, based on the
                    information provided by these methods.
                </para>
                <para>The event handler can provide a policy
                        <code>setRetryPolicy(RetryPolicy)</code> to tell the scheduler what to do in
                    such case. There are three policies, each for a specific scenario: <itemizedlist>
                        <listitem>
                            <para>
                                <code>RETRY_TRANSACTION</code> tells the event handler scheduler
                                that the entire transaction should be retried. It will reschedule
                                all the events in the current transaction for processing. This
                                policy is suitable when the event listener processes events to a
                                transactional data source that rolls back an entire transaction.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <code>RETRY_LAST_EVENT</code> is the policy that tells the scheduler
                                to only retry the last event in the transaction. This is suitable if
                                the underlying data source does not support transactions or if the
                                transaction was committed without the last event. </para>
                        </listitem>
                        <listitem>
                            <para>
                                <code>SKIP_FAILED_EVENT</code> will tell the scheduler to ignore the
                                exception and continue processing with the next event. The event
                                listener can still try to commit the underlying transaction to
                                persist any changed made while processing other events in this
                                transaction. This is the default policy. </para>
                        </listitem>
                    </itemizedlist></para>
                <para>Note that the
                    <code>SKIP_FAILED_EVENT</code>
                    is the default policy. For event
                    handlers that use an underlying mechanism to perform actions, this might not be
                    a suitable policy. Exceptions resulting from errors in these underlying systems
                    (such as databases or email clients) would cause events to be ignored when the
                    underlying system is unavailable. In error situations, the event listener should
                    inspect the exception (using the
                    <code>getException()</code>
                    method) and decide
                    whether it makes sense to retry processing of this event. If that is the case,
                    it should set the
                    <code>RETRY_LAST_EVENT</code>
                    or
                    <code>RETRY_TRANSACTION</code>
                    policy, depending on the transactional
                    behavior of the underlying system.
                </para>
                <para>When the chosen policy forces a retry of event processing, the processing is
                    delayed by the number of milliseconds defined in the
                    <code>retryInterval</code>
                    property. The default interval is 5 seconds.
                </para>
            </simplesect>
            <simplesect>
                <title>Manipulating transactions during event processing</title>
                <para>You can change transaction semantics event during event processing. This can
                    be done in one of two ways, depending on the type of event handler you use.
                </para>
                <para>If you use the
                    <code>@EventHandler</code>
                    annotation to mark event handler
                    methods, you may use a second parameter of type <code>TransactionStatus</code>.
                    If such parameter is available on the annotated method, the current
                    <code>TransactionStatus</code>
                    object is passed as a parameter.
                </para>
                <para>Alternatively, you can use the static
                    <code>TransactionStatus.current()</code>
                    accessor to gain access to the status of the current transaction. Note that this
                    method returns <code>null</code> if there is no active transaction.
                </para>
                <para>With the current transaction status, you can use the
                    <code>requestImmediateYield()</code>
                    and
                    <code>requestImmediateCommit()</code>
                    methods to end the transaction after
                    processing of the event. The former will also tell the scheduler to reschedule
                    the remainder of the events for another batch. The latter will use the yield
                    policy to see what needs to be done. Since the default yielding policy is
                    <code>YIELD_AFTER_TRANSACTION</code>, the behavior of both methods is
                    identical when using these defaults.
                </para>
            </simplesect>
            <simplesect>
                <title>Annotation support</title>
                <para>As with many of the other supported features in Axon, there is also annotation
                    support for transaction management. You have several options to configure
                    transactions.</para>
                <para>The first is to annotate methods on your EventListener with
                        <code>@BeforeTransaction</code> and <code>@AfterTransaction</code>. These
                    methods will be called before and after the execution of a transactional batch,
                    respectively. The annotated methods may accept a single parameter of type
                        <code>TransactionStatus</code>, which provides access to transaction
                    details, such as current status and configuration.</para>
                <para>Alternatively, you can use an external Transaction Manager, which you assign
                    to a field. If you annotate that field with <code>@TransactionManager</code>,
                    Axon will autodetect it and use it as transaction manager for that listener. The
                    transaction manager may be either one that implements the TransactionManager
                    interface, or any other type that uses annotations.</para>
            </simplesect>
            <simplesect>
                <title>Provided TransactionManager implementations</title>
                <para>Currently, Axon Framework provides one TransactionManager implementation, the
                        <code>SpringTransactionManager</code>. This implemenation uses Spring's
                        <code>PlatformTransactionManager</code> as underlying transaction mechanism.
                    That means the <code>SpringTransactionManager</code> can manage any transactions
                    in resources that Spring supports.</para>
            </simplesect>
        </sect2>
    </sect1>
</chapter>
